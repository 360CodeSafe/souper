----------------------------------------------------------------------

add instrinsics: bswap, x.with.overflow, ctpop, ctlz, cttz
add unreachable instruction
add insertvalue/extractvalue
add bitcast?

finish adding undefined behaviors
- nuw for add, sub, mul
- shift overflows
- exact shifts and divs
- mul and div overflows

factor UBs out of instructions to support fixing issue #13 and then to support
refinement proofs

make exploitation of undefined behavior on the LHS conditional on a command line
flag

RHS improvements:
- synthesize arbitrary-width integer constants
- synthesize undef values
- to guess instructions on the RHS, we need to implement the refinement check: 
  LHS assertion => (LHS == RHS) && RHS assertion 
- we can probably use techniques from here: 
  http://www.eecs.berkeley.edu/~jha/pubs/pldi-2011.pdf

external caching:
- add deserialization; test it by making sure x==deserialize(serialize(x))
- use Redis probably
- key is the same as in the internal cache, the serialized souper IR
- value is one of:
  - best known solution
  - no solution
  - solver timeout
  - solver hasn't been run on this one yet
  - flagged for manual inspection
- DB should encode souper verison and LLVM stuff such as target and version
- are there additional opportunities for canonicalizing souper IR?

interaction with dataflow analyses
- get intervals from LazyValueInfo, ConstantRange.cpp
- get bit info from computeKnownBits() functions from include/llvm/Analysis/ValueTracking.h
- teach souper to use assume, maybe using Philip's hack

eventually add vector, FP, and memory instructions

----------------------------------------------------------------------
